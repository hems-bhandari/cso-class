<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer System Organization Notes</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 20px auto;
            padding: 0 20px;
            background-color: #fdfdfd;
        }
        h1, h2, h3 {
            color: #005a9c;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 5px;
        }
        h1 {
            text-align: center;
            border-bottom: 3px solid #005a9c;
        }
        code {
            font-family: "Courier New", Courier, monospace;
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.95em;
        }
        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 5px solid #007acc;
        }
        blockquote {
            border-left: 5px solid #ccc;
            padding-left: 15px;
            margin-left: 0;
            font-style: italic;
            color: #555;
        }
        .container {
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .toc {
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .toc ul {
            padding-left: 20px;
        }
        .toc a {
            text-decoration: none;
            color: #005a9c;
        }
        .toc a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Computer System Organization Notes</h1>

        <div class="toc">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#t1">T1: Binary Representation and Memory Organization</a>
                    <ul>
                        <li><a href="#t1_1">Numbering Systems</a></li>
                        <li><a href="#t1_2">2-Complement Notation for Signed Integers</a></li>
                        <li><a href="#t1_3">Sign Extension</a></li>
                        <li><a href="#t1_4">Hexadecimal Notation</a></li>
                        <li><a href="#t1_5">Memory Organization & Endianness</a></li>
                    </ul>
                </li>
                <li><a href="#t2">T2: IEEE 754 Floating-Point Representation</a>
                    <ul>
                        <li><a href="#t2_1">Introduction to Floating-Point</a></li>
                        <li><a href="#t2_2">The IEEE 754 Standard (Single Precision)</a></li>
                        <li><a href="#t2_3">Special Floating Point Values</a></li>
                        <li><a href="#t2_4">Range, Precision, and Other Formats</a></li>
                        <li><a href="#t2_5">Floating-Point Arithmetic</a></li>
                        <li><a href="#t2_6">Accurate Arithmetic & Rounding</a></li>
                        <li><a href="#t2_7">Floating Point in RISC-V</a></li>
                    </ul>
                </li>
            </ul>
        </div>

        <h2 id="t1">T1: Binary Representation and Memory Organization</h2>

        <h3 id="t1_1">Numbering Systems</h3>
        <p>Digital computers store all information—numbers, text, images, and sound—in binary, a base-2 system. The meaning of these binary digits (bits) depends entirely on the context and the instructions applied to them.</p>
        
        <h4>Positional Numbering System</h4>
        <p>Both decimal (base-10) and binary (base-2) are positional systems. The value of a digit depends on its position.</p>
        <ul>
            <li><strong>Decimal Example:</strong> 5437 = (5 × 10³) + (4 × 10²) + (3 × 10¹) + (7 × 10⁰)</li>
            <li><strong>Binary Example:</strong> 1011₂ = (1 × 2³) + (0 × 2²) + (1 × 2¹) + (1 × 2⁰) = 8 + 0 + 2 + 1 = 11₁₀</li>
        </ul>

        <h4>Unsigned Binaries</h4>
        <p>For an unsigned number with <em>k</em> bits, the largest possible value is when all bits are 1. This value is <strong>2<sup>k</sup> - 1</strong>.</p>
        <ul>
            <li>For 4 bits, the largest value is 1111₂ = 2⁴ - 1 = 15.</li>
            <li>For 8 bits (a byte), the largest value is 2⁸ - 1 = 255.</li>
        </ul>

        <h3 id="t1_2">2-Complement Notation for Signed Integers</h3>
        <p>To represent both positive and negative integers, modern computers use <strong>2's complement</strong> notation. In this system, the most significant bit (MSB) also serves as the sign bit (0 for positive, 1 for negative).</p>
        
        <h4>Converting to Negative</h4>
        <p>To find the 2's complement representation of a negative number (-x):</p>
        <ol>
            <li>Take the binary representation of the positive number (x).</li>
            <li>Invert all the bits (1's complement).</li>
            <li>Add 1.</li>
        </ol>
        <pre><code>
Example: Find -6 in 4-bit 2's complement
1. Positive 6:   0110
2. Invert bits:  1001
3. Add 1:        1001 + 1 = 1010

So, -6 is represented as 1010₂.
        </code></pre>

        <h4>Range of 2-Complement Numbers</h4>
        <p>For a <em>k</em>-bit number, the range of values is from <strong>-(2<sup>k-1</sup>)</strong> to <strong>+(2<sup>k-1</sup> - 1)</strong>.</p>
        <ul>
            <li>For 4 bits: Range is -8 (1000₂) to +7 (0111₂).</li>
            <li>For 32 bits: Range is -(2³¹) to +(2³¹ - 1).</li>
        </ul>

        <h4>Overflow</h4>
        <p>Overflow occurs when the result of an arithmetic operation is outside the representable range. In 2's complement addition, overflow is detected when the carry-in to the sign bit is different from the carry-out from the sign bit.</p>
        <pre><code>
Example: 5 + 6 in 4-bit representation
  0101   (5)
+ 0110   (6)
-------
  1011   (-5 in 2's complement) --> Incorrect!

Carry bits into MSB: 1. Carry out: 0. Since 1 ≠ 0, overflow occurred.
        </code></pre>

        <h3 id="t1_3">Sign Extension</h3>
        <p>Sign extension is the process of increasing the number of bits of a binary number while preserving its sign and value. This is crucial when a smaller data type needs to be placed into a larger one (e.g., a 12-bit immediate value in a 32-bit register).</p>
        <ul>
            <li>To sign-extend, you copy the most significant bit (the sign bit) to all the new bits on the left.</li>
        </ul>
        <pre><code>
+6 in 4 bits:  0110  -->  +6 in 8 bits:  00000110 (copy the 0)
-2 in 4 bits:  1110  -->  -2 in 8 bits:  11111110 (copy the 1)
        </code></pre>
        <p>In RISC-V, instructions like <code>addi</code> automatically sign-extend the 12-bit immediate constant to 32 bits before performing the addition.</p>

        <h3 id="t1_4">Hexadecimal Notation</h3>
        <p>Hexadecimal (base-16) is a compact way to represent binary data. Each hexadecimal digit corresponds to a 4-bit binary sequence.</p>
        <ul>
            <li>Digits: 0-9 and A-F (representing 10-15).</li>
            <li>Example: The 32-bit binary number <code>1111 1111 1111 1111 1111 1111 1001 0111</code> is <code>0xFFFFFF97</code> in hex.</li>
        </ul>

        <h3 id="t1_5">Memory Organization & Endianness</h3>
        <h4>Memory as an Array of Bytes</h4>
        <p>Computer memory is a large, single-dimensional array of bytes. Each byte has a unique numerical address. A 32-bit integer, therefore, occupies four consecutive byte addresses.</p>
        
        <h4>Endianness</h4>
        <p>Endianness refers to the order in which bytes of a multi-byte word are stored in memory.</p>
        <blockquote>
            The question is: which end of the integer do we store at the lower address in memory?
        </blockquote>
        <ul>
            <li><strong>Big-Endian:</strong> The most significant byte ("big end") is stored at the lowest memory address. (e.g., MIPS, IBM POWER).</li>
            <li><strong>Little-Endian:</strong> The least significant byte ("little end") is stored at the lowest memory address. (e.g., RISC-V, Intel x86).</li>
        </ul>
        <pre><code>
Storing the 32-bit number 0x00000013 (decimal 19) starting at address 0x10001000:

Big-Endian:
Address      | Value
0x10001000   | 0x00
0x10001001   | 0x00
0x10001002   | 0x00
0x10001003   | 0x13

Little-Endian:
Address      | Value
0x10001000   | 0x13
0x10001001   | 0x00
0x10001002   | 0x00
0x10001003   | 0x00
        </code></pre>
        
        <hr>

        <h2 id="t2">T2: IEEE 754 Floating-Point Representation</h2>
        
        <h3 id="t2_1">Introduction to Floating-Point</h3>
        <p>Floating-point representation is used for non-integer numbers, including very small and very large values. It is analogous to scientific notation.</p>

        <h4>Normalization</h4>
        <p>In scientific notation, numbers are "normalized" to have a single non-zero digit before the decimal point. The same concept applies to binary floating-point numbers, where we want a single '1' before the binary point.</p>
        <ul>
            <li><strong>Decimal:</strong> 26.73 is normalized to 2.673 × 10¹</li>
            <li><strong>Binary:</strong> 1000.01₂ is normalized to 1.00001₂ × 2³</li>
        </ul>
        
        <h3 id="t2_2">The IEEE 754 Standard (Single Precision)</h3>
        <p>The IEEE 754 standard ensures that floating-point numbers are represented consistently across different machines. The 32-bit <strong>single-precision</strong> format is divided into three fields:</p>
        <pre>
 S |  Exponent (8 bits)  |      Fraction (23 bits)
(1)|      (2-8)          |           (9-32)
</pre>
        <ul>
            <li><strong>Sign (S):</strong> 1 bit. 0 for positive, 1 for negative.</li>
            <li><strong>Exponent:</strong> 8 bits. Represents the range of the number. It is stored in a <strong>biased</strong> format.</li>
            <li><strong>Fraction:</strong> 23 bits. Represents the precision of the number (also called the significand or mantissa).</li>
        </ul>

        <h4>Biased Exponent</h4>
        <p>Instead of 2's complement, the exponent is stored with a <strong>bias of 127</strong>. The actual exponent is calculated as: <code>Actual Exponent = Stored Exponent - 127</code>.</p>
        <p>The stored exponent values from 1 to 254 are used for normalized numbers.</p>
        <blockquote>
            <strong>Why use a bias?</strong> An advantage of biased representation is that non-negative floating-point numbers can be compared as if they were integers. A larger integer representation corresponds to a larger floating-point value, which simplifies hardware for comparisons.
        </blockquote>

        <h4>Value Calculation</h4>
        <p>For normalized numbers, the value is calculated as:</p>
        <p><strong>Value = (-1)<sup>S</sup> × (1.Fraction) × 2<sup>(Exponent - 127)</sup></strong></p>
        <p>The leading '1' in "1.Fraction" is implicit and not stored, which provides an extra bit of precision.</p>

        <pre><code>
Example: Represent -6.625 (-6 5/8)
1. Sign: Negative, so S = 1.
2. Binary: 6.625₁₀ = 110.101₂.
3. Normalize: 110.101₂ = 1.10101₂ × 2².
4. Fraction: The part after the binary point is 10101. We pad with zeros to 23 bits: 10101000000000000000000.
5. Exponent: Actual exponent is 2. Stored exponent = 2 + 127 = 129. In binary, this is 10000001₂.

Result:
Sign | Exponent | Fraction
 1   | 10000001 | 10101000000000000000000
        </code></pre>

        <h3 id="t2_3">Special Floating Point Values</h3>
        <p>The IEEE 754 standard reserves certain exponent values for special cases:</p>
        <ul>
            <li><strong>Exponent = 0 (all bits 0):</strong> Represents <strong>denormalized numbers</strong> for values very close to zero, and also represents <strong>zero</strong> itself (when the fraction is also 0).</li>
            <li><strong>Exponent = 255 (all bits 1):</strong>
                <ul>
                    <li>If Fraction = 0: Represents <strong>±Infinity</strong> (depending on the sign bit). Used for overflows.</li>
                    <li>If Fraction ≠ 0: Represents <strong>NaN (Not a Number)</strong>. Used for invalid operations like 0/0.</li>
                </ul>
            </li>
        </ul>

        <h3 id="t2_4">Range, Precision, and Other Formats</h3>
        <ul>
            <li><strong>Largest Number:</strong> Approx. 2¹²⁸. Represented by Sign=0, Exponent=254, and Fraction=all 1s.</li>
            <li><strong>Smallest Positive (Normalized) Number:</strong> Approx. 2⁻¹²⁶. Represented by Sign=0, Exponent=1, and Fraction=all 0s.</li>
        </ul>
        <h4>Other Formats</h4>
        <ul>
            <li><strong>Double Precision (64-bit):</strong> 1 sign bit, 11 exponent bits (bias 1023), 52 fraction bits. Used by `double` in C.</li>
            <li><strong>Half Precision (16-bit):</strong> 1 sign bit, 5 exponent bits, 10 fraction bits. Used in graphics and machine learning.</li>
        </ul>

        <h3 id="t2_5">Floating-Point Arithmetic</h3>
        <p>FP arithmetic is more complex than integer arithmetic.</p>
        <h4>Addition</h4>
        <ol>
            <li>Align the binary points: Shift the significand of the number with the smaller exponent to the right until its exponent matches the larger one.</li>
            <li>Add the significands.</li>
            <li>Renormalize the result (adjust the exponent and shift the significand until it's in 1.xxx form).</li>
            <li>Round the result to fit the available precision.</li>
        </ol>
        <h4>Multiplication</h4>
        <ol>
            <li>Add the exponents (and adjust the bias).</li>
            <li>Multiply the significands.</li>
            <li>Renormalize the result.</li>
            <li>Round the result.</li>
        </ol>
        <blockquote>
            <strong>Floating-point addition is NOT associative!</strong><br>
            Due to precision and rounding limitations, <code>(x + y) + z</code> is not always equal to <code>x + (y + z)</code>. This is especially true when mixing very large and very small numbers.
        </blockquote>

        <h3 id="t2_6">Accurate Arithmetic & Rounding</h3>
        <p>Because intermediate calculations can produce more bits than can be stored, rounding is essential. Inaccurate rounding can lead to significant errors.</p>
        <p>The famous <strong>Vancouver Stock Exchange error of 1982</strong> was caused by consistently truncating (rounding down) an index value instead of rounding to the nearest value. Over time, this small error compounded, causing the index to lose nearly half its value.</p>
        
        <h4>Guard, Round, and Sticky Bits</h4>
        <p>To improve accuracy, hardware can use extra bits during intermediate calculations:</p>
        <ul>
            <li><strong>Guard Bit:</strong> An extra bit to the right of the significand to catch a value shifted out.</li>
            <li><strong>Round Bit:</strong> The first bit to be truncated after the guard bit.</li>
            <li><strong>Sticky Bit:</strong> A single bit that is set to 1 if <em>any</em> of the bits to the right of the round bit are 1. This helps differentiate between a result that is exactly halfway and one that is slightly over.</li>
        </ul>
        <p>These extra bits allow for more accurate rounding, such as the "round to nearest, ties to even" default mode in IEEE 754.</p>

        <h3 id="t2_7">Floating Point in RISC-V</h3>
        <p>RISC-V provides dedicated support for IEEE 754 floating-point operations.</p>
        <ul>
            <li><strong>FP Registers:</strong> A separate set of 32 registers (<code>f0</code>-<code>f31</code>) to store floating-point operands.</li>
            <li><strong>Extensions:</strong>
                <ul>
                    <li><strong>F Extension:</strong> Adds 32-bit single-precision support.</li>
                    <li><strong>D Extension:</strong> Widens the FP registers to 64 bits for double-precision support.</li>
                </ul>
            </li>
            <li><strong>Instructions:</strong> Provides a dedicated set of instructions that operate on the FP registers, such as:
                <ul>
                    <li><code>flw, fsw</code>: Load/store single-precision word.</li>
                    <li><code>fadd.s, fsub.s, fmul.s, fdiv.s</code>: Single-precision arithmetic.</li>
                    <li><code>fcvt.w.s</code>: Convert float to integer.</li>
                    <li><code>fcvt.s.w</code>: Convert integer to float.</li>
                </ul>
            </li>
        </ul>
    </div>
</body>
</html>
